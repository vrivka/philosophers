# Philosophers
Учебный проект на языке C для понимания многопоточности и решения "[Задачи об обедающих философах](https://ru.wikipedia.org/wiki/%D0%97%D0%B0%D0%B4%D0%B0%D1%87%D0%B0_%D0%BE%D0%B1_%D0%BE%D0%B1%D0%B5%D0%B4%D0%B0%D1%8E%D1%89%D0%B8%D1%85_%D1%84%D0%B8%D0%BB%D0%BE%D1%81%D0%BE%D1%84%D0%B0%D1%85)".
## Оглавление

1. [Описание](#Описание)
2. [Постановка задачи](#Постановка-задачи)
3. [Мое решение](#Мое-решение)
4. [Итог](#Итог)
## Описание

Цель проекта научиться работать с множеством потоков, понять проблему взаимного блокирования в многопоточных программах. Для этих целей использована "Задача об обедающих философах".

- Один или несколько философов сидят за круглым столом. В центре стола стоит большая тарелка со спагетти.
- Философы попеременно едят, думают или спят. Пока они едят, они не думают и не спят; пока думают, они не едят и не спят; и, конечно, пока спят, они не едят и не думают.
- На столе также лежат вилки. Вилок столько же, сколько философов.
- Поскольку подавать и есть спагетти только одной вилкой не очень удобно, философ берет правую и левую вилки, по одной в каждую руку.
- Покончив с едой, философ кладет вилки обратно на стол и засыпает. Проснувшись, начинает думать. Симуляция останавливается, когда философ умирает от голода.
- Каждый философ должен есть и никогда не должен голодать.
- Философы не разговаривают друг с другом.
- Философы не знают, что другой философ вот-вот умрет.

## Постановка задачи

|||
|----------------|----------------|
| Имя программы | philo |
| Файлы | Makefile, *.h, *.c, in directory philo/ |
| Makefile | NAME, all, clean, fclean, re |
| Аргументы | number_of_philosophers time_to_die time_to_eat time_to_sleep \[number_of_times_each_philosopher_must_eat\] |
| Разрешенные функции | memset, printf, malloc, free, write, usleep, gettimeofday, pthread_create, pthread_detach, pthread_join, pthread_mutex_init, pthread_mutex_destroy, pthread_mutex_lock, pthread_mutex_unlock |

Нужно написать программу соблюдая следующие правила:

- Глобальные переменные запрещены!
- Программа должна принимать следующие аргументы:
    - **number_of_philosophers**: количество философов, а также количество вилок;
    - **time_to_die** (в миллисекундах): если философ не начал есть _time_to_die_ с начала своего последнего приема пищи или начала симуляции, он умирает;
    - **time_to_eat** (в миллисекундах): время, которое требуется философу, чтобы поесть. Во время этого им нужно будет держать две вилки.
    - **time_to_sleep** (в миллисекундах): время, которое философ проведет во сне.
    - **number_of_times_each_philosopher_must_eat** (необязательный аргумент): если все философы съели хотя бы _number_of_times_each_philosopher_must_eat_ раз симуляция останавливается. Если не указано, симуляция останавливается, когда философ умирает.
- У каждого философа есть число от 1 до _number_of_philosophers_.
- Философ номер 1 сидит рядом с философом номер _number_of_philosophers_. Любой другой философ с номером N находится между философом с номером N - 1 и философом с номером N + 1.

О логах программы:
- Любое изменение состояния философа должно быть оформлено следующим образом:
    - timestamp_in_ms X has taken a fork 
    - timestamp_in_ms X is eating
    - timestamp_in_ms X is sleeping
    - timestamp_in_ms X is thinking
    - timestamp_in_ms X died
> timestamp_in_ms - текущая метка времени в миллисекундах, 
> X - номер философа.
- Отображаемое сообщение о состоянии не следует путать с другим сообщением.
- Сообщение о смерти философа должно отображаться не более чем через 10 мс после фактической смерти философа.

Особые правила:
- Каждый философ должен быть потоком.
- Между каждой парой философов есть одна развилка. Следовательно, если философов несколько, то у каждого философа есть вилка слева и вилка справа. Если есть только один философ, на столе должна быть только одна вилка.
- Чтобы предотвратить дублирование вилок философами, вы должны защитить состояние вилок с помощью мьютекса для каждого из них.
## Мое решение

Нам потребуется решить проблему взаимной блокировки. Когда философы берут по одной вилке одновременно (блокируют мьютексы левой вилки), взять правую вилку становится невозможно так как она является левой вилкой для философа справа. Отсюда следует, что философы не могут начать есть и умирают, так как для начала еды им требуется две вилки.

Можно было бы установить индикатор того что вилка была взята. Но из условия задачи философы не могут общаться друг с другом, и соответственно не могут сказать, что они взяли по вилке.

Мое решение предлагает установить незначительный временной разрыв между взятием вилок для четных и нечетных философов. Тогда у философов с порядковыми номерами 1, 3, 5, 7 и т. д. будет время для взятия двух вилок.

Но к сожалению, философы все еще могут умереть от голода, так как входные данные могут этому поспособствовать.

Для решения задачи нам потребуется общая структура и структура, которая будет отвечать за одного философа.

#### Общая структура
```C
typedef struct s_all
{
	unsigned int	num_philo;	// количество философов (1 аргумент)
	unsigned int	time_to_die;	// время до смерти (2 аргумент)
	unsigned int	time_to_eat;	// время для еды (3 аргумент)
	unsigned int	time_to_sleep;	// время на сон (4 аргумент)
	int		eat_times;	// количество приемов пищи (5 аргумент опционально)
	unsigned int	all_eat;	// количество насытившихся философов
	int		status;		// общий статус симуляции
	long		time_start;	// временная метка старта симуляции
	pthread_mutex_t	pause;		// мьютекс паузы для одновременного старта симуляции 
	pthread_mutex_t	print_m;	// мьютекс для печати
	t_philo		*philo;		// указатель на массив философов
}	t_all;
```
#### Структура для одного философа
```C
typedef struct s_philo
{
	pthread_mutex_t	*pause;         // указатель на мьютекс паузы
	pthread_mutex_t	*print_m;       // указатель на мьютекс для печати
	pthread_mutex_t	left_fork;      // мютекс для левой вилки
	pthread_mutex_t	*right_fork;    // указатель на мьютекс левой вилки правого философа (правая вилка) 
	pthread_t	philo;          // дискриптор потока философа
	pthread_t	monitor;        // дискриптор потока монитора философа
	long		*time_start;    // указатель на временную метку старта симуляции
	int		*status;        // указатель на общий статус симуляции
	int		odd;            // идентификатор чётности философа
	unsigned int	num;            // номер философа
	unsigned int	time_to_die;    // время до смерти философа
	unsigned int	time_to_eat;    // время требуемое для еды
	unsigned int	time_to_sleep;  // время на сон
	int 		eat_times;      // количество приемов пищи
	long		last_meal_time; // временная метка последнего приема пищи
}	t_philo;
```

После валидации аргументов и инициализации структур, блокируется мьютекс паузы, запускается создание потоков, после чего пауза разблокируется и начинается симуляция.

```C
static int	start_philo(t_all *all)
{
	int	ret;
	
	pthread_mutex_lock(&all->pause);
	ret = create_threads(all);
	pthread_mutex_unlock(&all->pause);
	if (all->eat_times > 0)
		eat_counter(all);
	philo_wait(all);
	return (ret);
}
```
#### Поток философа
```C
void	*philo_thread(void *ptr)
{
	t_philo	*philo;

	philo = (t_philo *)ptr;
	pthread_mutex_lock(philo->pause);
	pthread_mutex_unlock(philo->pause);
	if (!philo->odd)
		my_usleep(1000);
	while (*philo->status == ALIVE)
	{
		take_fork(philo);
		eat(philo);
		drop_fork(philo);
		sleep_think(philo);
	}
	return (NULL);
}
```
Для каждого философа создается поток монитор, для отслеживания состояния философа.
#### Поток монитора
```C
void	*philo_monitor(void *ptr)
{
	t_philo	*philo;

	philo = (t_philo *)ptr;
	pthread_mutex_lock(philo->pause);
	pthread_mutex_unlock(philo->pause);
	philo->last_meal_time = get_time();
	while (*philo->status == ALIVE && (philo->last_meal_time
			+ philo->time_to_die - get_time()) / 1000 >= 0)
		my_usleep(100);
	if (*philo->status == ALIVE)
		*philo->status = DEAD_M;
	pthread_mutex_lock(philo->print_m);
	if (*philo->status == DEAD_M)
	{
		printf("%ld %d %s\n", (get_time() - *philo->time_start) / 1000,
			   philo->num, IS_DEAD);
		*philo->status = DEAD;
	}
	pthread_mutex_unlock(philo->print_m);
	pthread_mutex_unlock(philo->right_fork);
	pthread_mutex_unlock(&philo->left_fork);
	pthread_join(philo->philo, NULL);
	return (NULL);
}
```
Также потребуется печатать состояние философа, когда оно изменяется. Но есть проблема, когда вывелось сообщение, что один философ умер, а после этого сообщения другой начал есть. Этого не должно происходить, так как симуляция после смерти философа должна завершиться. Для решения этой проблемы заведен мьютекс на печать, и когда один философ умирает, то мьютекс на печать блокируется.
#### Функция печати состояния
```C
void	print_massage(long timestamp, char *massage, t_philo *philo)
{
	pthread_mutex_lock(philo->print_m);
	if (*philo->status == ALIVE)
		printf("%ld %d %s\n", timestamp, philo->num, massage);
	pthread_mutex_unlock(philo->print_m);
}
```
#### Примеры запуска программы
Все философы живы:
```
./philo 4 410 200 200
```
Всем философам хватает времени для еды и сна, и теоретически симуляция никогда не остановится.

Все философы живы, и симуляция остановится, когда каждый философ поест как минимум 7 раз:
```
./philo 5 800 200 200 7
```

Случай, когда один из философов умирает:
```
./philo 4 310 200 100
```
В этом случае философу не хватает времени для взятия вилок и еды.

Интересный случай, когда есть всего один философ:
```
./philo 1 1000 200 100
```
В этом случае неважно сколько времени философ ест или спит, так как у него всего одна вилка, и он никогда не сможет начать есть. Симуляция остановится через 1000 милисекунд, когда истечет время смерти.
# Итог
В данном проекте я научился запускать множество потоков, блокировать мьютексы, также решил проблему взаимной блокировки.

Результаты запуска программы могут отличаться, в зависимости от загруженности системы и количества ядер процессора.